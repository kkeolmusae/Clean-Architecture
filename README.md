# Clean Architecture

> 💡 < Clean Architecture > 을 읽으며 정리한 글입니다.

</br>

## 클린 아키텍쳐란 무엇인가

### 추천사

- 소프트웨어 아키텍처는 특정한 모습을 지니지 않는다. 어떤 모습으로 시각화할지는 선택일 뿐, 정해져 있지 않다. 우리는 이때 가장 깔끔한(clean) 길을 선택해야 한다. 이 길은 소프트웨어가 지닌 '부드러움(softness)' 을 인지하고, 이 부드러움을 시스템에서 최우선으로 보존하는 것을 목표로 한다. 이 길은 우리가 불완전한 지식에 기초해 행동한다는 사실을 인정할 뿐만 아니라, 불완전한 지식으로 행동하는 것이야 말로 인간으로서 우리가 무엇인가를 하는 방식이며, 우리의 뛰어난 부분임을 이해한다. 

- 아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 더 가까움을 이해해야 좋은 아키텍처가 만들어진다.

> 빨리 가는 유일한 방법은 제대로 가는 것이다. 
> 
> \- 로버트 C. 마틴 (Robert C. Martin)


  </br>

### 서문
- 컴퓨터 프로그래밍을 하는 관행을 유심히 관찰해보면 지난 50년동안 언어는 조금 발전했고 도구는 환상적으로 좋아졌지만 **컴퓨터 프로그래밍을 이루는 기본 구성요소는 조금도 바뀌지 않았다.**

- 코드가 변하지 않았다는 사실이 시스템의 종류와 관계없이 소프트웨어 아키텍처의 규칙이 일관된 이유다. 소프트웨어 아키텍처의 규칙이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이다. 그리고 이 구성요소가 보편적이며 변하지 않았으므로, 이들을 정렬하는 규칙 역시도 보편적이며 변한 것이 없다.

- 이 책은 **세월이 흘러도 변치않는 소프트웨어 설계 규칙**에 관한 것이다.

</br>

### 공부 계획

- 2023년도 남은 2분기동안 1회 정독해보자.

</br>

### 공부 목표

- 아키텍처 설계에 대해 알아보자

</br>

### 목차

#### === 1부 소개 ===
1장 설계와 아키텍처란?
- 목표는?
- 사례 연구
- 결론

2장 두 가지 가치에 대한 이야기
- 행위
- 아키텍처
- 더 높은 가치
- 아이젠하워 매트릭스
- 아키텍처를 위해 투쟁하라

#### === 2부 벽돌부터 시작하기: 프로그래밍 패러다임 ===
3장 패러다임 개요
- 구조적 프로그래밍
- 객체 지향 프로그래밍
- 함수형 프로그래밍
- 생각할 거리
- 결론

4장 구조적 프로그래밍
- 증명
- 해로운 성명서
- 기능적 분해
- 엄밀한 증명은 없었다
- 과학이 구출하다
- 테스트
- 결론

5장 객체 지향 프로그래밍
- 캡슐화?
- 상속?
- 다형성?
- 결론

6장 함수형 프로그래밍
- 정수를 제곱하기
- 불변성과 아키텍처
- 가변성의 분리
- 이벤트 소싱
- 결론

#### === 3부 설계 원칙 ===
7장 SRP: 단일 책임 원칙
- 징후 1: 우발적 중복
- 징후 2: 병합
- 해결책
- 결론

8장 OCP: 개방-폐쇄 원칙
- 사고 실험
- 방향성 제어
- 정보 은닉
- 결론

9장 LSP: 리스코프 치환 원칙
- 상속을 사용하도록 가이드하기
- 정사각형/직사각형 문제
- LSP와 아키텍처
- LSP 위배 사례
- 결론

10장 ISP: 인터페이스 분리 원칙
- ISP와 언어
- ISP와 아키텍처
- 결론

11장 DIP: 의존성 역전 원칙
- 안정된 추상화
- 팩토리
- 구체 컴포넌트
- 결론

#### === 4부 컴포넌트 원칙 ===
12장 컴포넌트
- 컴포넌트의 간략한 역사
- 재배치성
- 링커
- 결론

13장 컴포넌트 응집도
- REP: 재사용/릴리스 등가 원칙
- CCP: 공통 폐쇄 원칙
- CRP: 공통 재사용 원칙
- 컴포넌트 응집도에 대한 균형 다이어그램
- 결론

14장 컴포넌트 결합
- ADP: 의존성 비순환 원칙
- 하향식(top-down) 설계
- SDP: 안정된 의존성 원칙
- SAP: 안정된 추상화 원칙
- 결론

#### === 5부 아키텍처 ===
15장 아키텍처란?
- 개발
- 배포
- 운영
- 유지보수
- 선택사항 열어 두기
- 장치 독립성
- 광고 우편
- 물리적 주소 할당
- 결론

16장 독립성
- 유스케이스
- 운영
- 개발
- 배포
- 선택사항 열어놓기
- 계층 결합 분리
- 유스케이스 결합 분리
- 결합 분리 모드
- 개발 독립성
- 배포 독립성
- 중복
- 결합 분리 모드(다시)
- 결론

17장 경계: 선 긋기
- 두 가지 슬픈 이야기
- FitNesse
- 어떻게 선을 그을까? 그리고 언제 그을까?
- 입력과 출력은?
- 플러그인 아키텍처
- 플러그인에 대한 논의
- 결론

18장 경계 해부학
- 경계 횡단하기
- 두려운 단일체
- 배포형 컴포넌트
- 스레드
- 로컬 프로세스
- 서비스
- 결론

19장 정책과 수준
- 수준
- 결론

20장 업무 규칙
- 엔티티
- 유스케이스
- 요청 및 응답 모델
- 결론

21장 소리치는 아키텍처
- 아키텍처의 테마
- 아키텍처의 목적
- 하지만 웹은?
- 프레임워크는 도구일 뿐, 삶의 방식은 아니다
- 테스트하기 쉬운 아키텍처
- 결론

22장 클린 아키텍처
- 의존성 규칙
- 전형적인 시나리오
- 결론

23장 프레젠터와 험블 객체
- 험블 객체 패턴
- 프레젠터와 뷰
- 테스트와 아키텍처
- 데이터베이스 게이트웨이
- 데이터 매퍼
- 서비스 리스너
- 결론

24장 부분적 경계
- 마지막 단계를 건너뛰기
- 일차원 경계
- 퍼사드
- 결론

25장 계층과 경계
- 움퍼스 사냥 게임
- 클린 아키텍처?
- 흐름 횡단하기
- 흐름 분리하기
- 결론

26장 메인(Main) 컴포넌트
- 궁극적인 세부사항
- 결론

27장 ‘크고 작은 모든’ 서비스들
- 서비스 아키텍처?
- 서비스의 이점?
- 야옹이 문제
- 객체가 구출하다
- 컴포넌트 기반 서비스
- 횡단 관심사
- 결론

28장 테스트 경계
- 시스템 컴포넌트인 테스트
- 테스트를 고려한 설계
- 테스트 API
- 결론

29장 클린 임베디드 아키텍처
- 앱-티튜드 테스트
- 타깃-하드웨어 병목현상
- 결론

#### === 6부 세부사항 ===
30장 데이터베이스는 세부사항이다
- 관계형 데이터베이스
- 데이터베이스 시스템은 왜 이렇게 널리 사용되는가?
- 디스크가 없다면 어떻게 될까?
- 세부사항
- 하지만 성능은?
- 개인적인 일화
- 결론

31장 웹은 세부사항이다
- 끝없이 반복하는 추
- 요약
- 결론

32장 프레임워크는 세부사항이다
- 프레임워크 제작자
- 혼인 관계의 비대칭성
- 위험 요인
- 해결책
- 이제 선언합니다
- 결론

33장 사례 연구: 비디오 판매
- 제품
- 유스케이스 분석
- 컴포넌트 아키텍처
- 의존성 관리
- 결론

34장 빠져 있는 장
- 계층 기반 패키지
- 기능 기반 패키지
- 포트와 어댑터
- 컴포넌트 기반 패키지
- 구현 세부사항엔 항상 문제가 있다
- 조직화 vs. 캡슐화
- 다른 결합 분리 모드
- 결론: 빠져 있는 조언

#### === 7부 부록 ===
부록 A 아키텍처 고고학
